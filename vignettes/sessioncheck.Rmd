---
title: "sessioncheck"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sessioncheck}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The goal of **sessioncheck** is to provide simple tools that can be called at the top of a script, and produce warnings or errors if it detects signs that the script is not being executed in a clean R session. The intended user for **sessioncheck** is a beginner or intermediate level R user who has learned enough about R to understand the limitations of using `rm(list = ls())` as a method to clean the R session, but is perhaps not at the point that they can take advantage of sophisticated tools like [targets](https://books.ropensci.org/targets/), [callr](https://callr.r-lib.org/), and so on. 

## Why is this important?

A common practice when writing R scripts is to include a snippet of code like `rm(list = ls())` at the top of the script. The reason people do this is for reproducibility purposes, to ensure that the script is run in the context of a "clean" R session. The goal is a good one, but the method used to attain it is not very effective. The only thing that `rm(list = ls())` does is remove any variables currently stored in the global environment, but this is only one of many different ways in which previously-executed code can alter the state of the R session. This approach doesn't provide any degree of safety from any of the following:

- packages may have been loaded with `library()`
- data sets may have been added to the search path with `attach()`
- options may have been set with `options()`
- "hidden" variables in the global environment like `.Random.seed`
- (...and a long list of other more subtle things)

Any of these can affect how your script executes, and `rm(list = ls())` does not protect you against any of them. Because of this, a better practice is to **restart the R session** immediately before running the script. By running the script in a fresh R session, you're much less likely to encounter these issues.

## How does sessioncheck help?

The principle that underpins **sessioncheck** is that scripts should not attempt a "clean up" of the environment. A better approach is to include a snippet of code that inspects the state of the R session, and produces a warning (or even an error) if it detects signs that the script is not being run in a clean session. The simplest way to do this is with the `check_session()` function. The user could put this as the very line of their R script:

```{r}
#| label: basic-use
#| eval: false
sessioncheck::check_session("error")
```

When executed in a clean R session this function does nothing, and the script will continue to run as it normally would. However, if the session is "dirty" -- for some specific interpretation of what that means -- it will produce an error, prevent the script from running, and prompt the user to consider restarting the R session. 

This intended behaviour is very easy to illustrate in this vignette, because the environment inside the R markdown document has been altered in many ways that make it different from a "typical" clean R session. Here is an example showing the error that a user might see if they run a "session checked" script in a dirty R session:

```{r}
#| label: error-example
#| error: true
sessioncheck::check_session("error")
```

The error message lists two specific problems:

- several "unapproved" packages have been loaded via namespace
- one "unapproved" environment has been appended to the search path

This is then followed by a prompt for the user to restart R.

## How does sessioncheck work?

The **sessioncheck** package is built on several functions that each check one specific aspect to the R session: the `check_session()` function itself merely aggregates the results of the individual checks. When calling `check_session()` you can customise exactly which checks are performed and what rules should apply to each check, but for now let's look at what the individual check functions do. Let's load the package first, so that we can explore the behaviour of the check functions one at a time:

```{r}
#| label: load-package
library(sessioncheck)
```

### Check the global environment

The first and simplest of the checks is `check_globalenv()`, and it focuses on the same aspect of the R session that the traditional `rm(list=ls())` method does: the contents of the global environment. At the moment there is nothing in the global environment, so it is considered "clean". As a consequence, nothing happens when we run this check:

```{r}
#| label: check-globalenv
check_globalenv()
```

To get the check to produce a warning, we'll need to add some variables:

```{r}
visible_1 <- "this will get detected"
visible_2 <- "so will this"
.hidden_1 <- "but this will not"

check_globalenv()
```


### Check the attached packages

```{r}
#| label: check-packages
check_packages()
```


### Check for other attached environments

```{r}
#| label: check-attachments
check_attachments()
```


### Check loaded namespaces

```{r}
#| label: check-namespaces
check_namespaces()
```


