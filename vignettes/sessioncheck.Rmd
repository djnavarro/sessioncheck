---
title: "sessioncheck"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sessioncheck}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(width = 74)
```

The goal of **sessioncheck** is to provide simple tools that can be called at the top of a script, and produce warnings or errors if it detects signs that the script is not being executed in a clean R session. The intended user for **sessioncheck** is a beginner or intermediate level R user who has learned enough about R to understand the limitations of using `rm(list = ls())` as a method to clean the R session, but is perhaps not at the point that they can take advantage of sophisticated tools like [targets](https://books.ropensci.org/targets/), [callr](https://callr.r-lib.org/), and so on. 

## Why is this important?

A common practice when writing R scripts is to include a snippet of code like `rm(list = ls())` at the top of the script. The reason people do this is for reproducibility purposes, to ensure that the script is run in the context of a "clean" R session. The goal is a good one, but the method used to attain it is not very effective. The only thing that `rm(list = ls())` does is remove any variables currently stored in the global environment, but this is only one of many different ways in which previously-executed code can alter the state of the R session. This approach doesn't provide any degree of safety from any of the following:

- packages may have been loaded with `library()`
- data sets may have been added to the search path with `attach()`
- options may have been set with `options()`
- "hidden" variables in the global environment like `.Random.seed`
- (...and a long list of other more subtle things)

Any of these can affect how your script executes, and `rm(list = ls())` does not protect you against any of them. Because of this, a better practice is to **restart the R session** immediately before running the script. By running the script in a fresh R session, you're much less likely to encounter these issues.

## How does sessioncheck help?

The principle that underpins **sessioncheck** is that scripts should not attempt a "clean up" of the environment. A better approach is to include a snippet of code that inspects the state of the R session, and produces a warning (or even an error) if it detects signs that the script is not being run in a clean session. The simplest way to do this is with the `sessioncheck()` function. In the typical case, you wouldn't load the package with `library()`. Instead, you would put this as the very line of their R script:

```{r}
#| label: basic-use
#| eval: false
sessioncheck::sessioncheck("error")
```

When executed in a clean R session this function does nothing, and the script will continue to run as it normally would. However, if the session is "dirty" -- for some specific interpretation of what that means -- it will produce an error, prevent the script from running, and prompt the user to consider restarting the R session. 

This intended behaviour is very easy to illustrate in this vignette, because the environment inside the R markdown document has been altered in many ways that make it different from a "typical" clean R session. Here is an example showing the error that a user might see if they run a "session checked" script in a dirty R session:

```{r}
#| label: error-example
#| error: true
sessioncheck::sessioncheck("error")
```

The error lists specific issues that were detected and prompts the user to restart R.

## How does sessioncheck work?

The **sessioncheck** package is built on several functions that each check one specific aspect to the R session: the `sessioncheck()` function itself merely aggregates the results of the individual checks. 

When calling `sessioncheck()` you can customise exactly which checks are performed and what rules should apply to each check, but for now let's look at what the individual check functions do. For the purposes of this vignette we'll only look at the three checks that are performed by default: checks of the global environment, checks of the attached packages, and checks of the attached non-package environments. Let's load the package, so that we can explore the behaviour of these three check functions one at a time

```{r}
#| label: load-package
library(sessioncheck)
```

### Check 1: global environment

The first and simplest of the checks is `check_globalenv()`, and it focuses on the same aspect of the R session that the traditional `rm(list=ls())` method does: the contents of the global environment. At the moment there is nothing in the global environment, so it is considered "clean". As a consequence, nothing happens when we run this check:

```{r}
#| label: check-globalenv
check_globalenv()
```

To get the check to produce a warning, we'll need to add some variables:

```{r}
visible_1 <- "this will get detected"
visible_2 <- "so will this"
.hidden_1 <- "but this will not"

check_globalenv()
```


### Check 2: attached packages

```{r}
#| label: check-packages
check_packages()
```

The warning notes that the **sessioncheck** package has been attached. This might be considered acceptable, so we can ask the check to `allow` this package:

```{r}
check_packages(action = "warn", allow = "sessioncheck")
```

The check invisibly returns a status object that looks like this:

```{r}
status <- check_packages(action = "none")
status
```


### Check 3: other attachments

```{r}
#| label: check-attachments
check_attachments()
```

The check invisibly returns a status object that looks like this:

```{r}
status <- check_attachments(action = "none")
status
```


### Other checks

There are other checks that are not called by default:

- `check_namespaces()` looks for packages that have been loaded but not attached
- TODO: `check_options()` looks for specific options that might be of concern
- TODO: `check_locale()` looks for locale settings that might be of concern
- TODO: `check_sysenv()` looks for system environment variables





